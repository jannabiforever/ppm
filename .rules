# Type rules

## No any

Don't ever use `any` type to infer types.

## No null or undefined

It is anti-pattern to use null or undefined in `Effect.ts`,
because it doesn't provide any information about the context.

`Effect.ts` provides a way to handle null / undefined values, using `Option` type.
In this project, we use `Option` type to handle null / undefined values.

# Effect.ts 관련 코드 룰

## Naming Conventions

- `Effect`나, `() => Effect` 타입은 내부 로직이 동기인지, 비동기인지를 구분하기 위해 변수명의 맨 뒤에 `Sync` 또는 `Async`를 붙인다.

```ts
export class SupabaseService extends Context.Tag('Supabase')<
	SupabaseService,
	{
		readonly getClientSync: () => Effect.Effect<SupabaseClient>;
		readonly safeGetSessionAsync: () => Effect.Effect<
			{ session: Session | null; user: User | null },
			SupabaseAuthError
		>;
	}
>() {}

export const SupabaseLive = Layer.effect(
	SupabaseService,
	Effect.gen(function* () {
		const cookies = yield* CookiesService;
		const client: SupabaseClient<Database> = createServerClient(
			PUBLIC_SUPABASE_URL,
			PUBLIC_SUPABASE_ANON_KEY,
			{
				cookies: Effect.runSync(cookies.plainCookieSync())
			}
		);

		return {
			getClientSync: () => Effect.succeed(client),
			safeGetSessionAsync: () => {
				const sessionResult = Effect.promise(() => client.auth.getSession()).pipe(
					Effect.flatMap(({ data: { session }, error }) => {
						return error === null ? Effect.succeed(session) : Effect.fail(mapAuthError(error));
					})
				);

				const userResult = Effect.promise(() => client.auth.getUser()).pipe(
					Effect.flatMap(({ data: { user }, error }) => {
						return error === null ? Effect.succeed(user) : Effect.fail(mapAuthError(error));
					})
				);

				return Effect.all([sessionResult, userResult]).pipe(
					Effect.map(([session, user]) => ({ session, user }))
				);
			}
		};
	})
);
```

위 예시에서, `getClientSync`는 동기적으로 `SupabaseClient`를 반환하는 함수를 제공하고,
`safeGetSessionAsync`는 비동기적으로 세션과 사용자 정보를 가져오는 함수를 제공한다.

물론 결국 모든 `Effect`는 lazy하게 평가되긴 하지만, `Effect.runSync`를 사용할지 `Effect.runPromise`를 사용할지를
개발자가 잘 구분할 수 있도록 위 네이밍 컨벤션을 따라야 한다.

## Excessive Nesting

Effect 파이프라인에서 중첩된 nesting이 많아지면 코드의 가독성과 유지보수성이 떨어진다.
따라서, pipe를 활용한 함수형 중첩을 해야 한다.

예를 들어, Effect 파이프라인을 작성할 때,

```typescript
// ❌ BAD: excessive nesting
const result = await Effect.runPromise(
    Effect.gen(function* () {
        const client = yield* supabaseService.getClientSync();
        const session = yield* Effect.promise(() => client.auth.getSession()).pipe(
            Effect.flatMap(({ data, error }) => {
                if (error) {
                    return Effect.fail(error);
                } else {
                    return Effect.succeed(data.session);
                }
            })
        );
        return session;
    }).pipe(
        Effect.catchAll((error) => {
            return Effect.succeed(null);
        })
    )
);
```

과 같은 코드는 `Effect.runPromise` 안에 모든 로직이 중첩되어 가독성이 떨어지지만,

```typescript
// ✅ GOOD: pipe 체인 활용
const result = await Effect.gen(function* () {
    const client = yield* supabaseService.getClientSync();
    const session = yield* Effect.promise(() => client.auth.getSession()).pipe(
        Effect.flatMap(({ data, error }) => {
            if (error) {
                return Effect.fail(error);
            } else {
                return Effect.succeed(data.session);
            }
        })
    );
    return session;
}).pipe(
    Effect.catchAll(() => Effect.succeed(null)),
    Effect.runPromise
);
```

과 같은 코드는 pipe 체인을 활용하여 nesting을 줄이고 가독성을 높인다. 따라서 pipe의 활용을 극대화하는 방향으로 코드를 작성한다.

# Testing Conventions

이 프로젝트는 Effect.ts 기반 서비스 아키텍처를 위한 종합적인 테스팅 컨벤션을 따른다.

## 참조 문서

자세한 테스팅 규칙과 패턴은 [`.testing-conventions.md`](./.testing-conventions.md) 파일을 참조한다.

## 핵심 원칙

1. **Effect 파이프라인 테스트**: 구현 세부사항이 아닌 비즈니스 로직을 테스트한다
2. **의존성 격리**: Supabase, 외부 API 등 외부 의존성을 모킹한다
3. **에러 시나리오 검증**: 성공 경로와 실패 경로를 모두 테스트한다
4. **서비스 레이어 중심**: 스키마 검증, 비즈니스 로직, 통합 테스트로 구분한다

## 필수 테스트 카테고리

- **Schema Validation Tests**: 입력 검증 및 타입 안전성
- **Business Logic Unit Tests**: 순수 비즈니스 로직 함수들
- **Service Integration Tests**: 전체 Effect 파이프라인 및 의존성
- **Error Handling Tests**: Effect 에러 전파 및 처리
