# Effect.ts 관련 코드 룰

## Naming Conventions

- `Effect`나, `() => Effect` 타입은 내부 로직이 동기인지, 비동기인지를 구분하기 위해 변수명의 맨 뒤에 `Sync` 또는 `Async`를 붙인다.

```ts
export class SupabaseService extends Context.Tag('Supabase')<
	SupabaseService,
	{
		readonly getClientSync: () => Effect.Effect<SupabaseClient>;
		readonly safeGetSessionAsync: () => Effect.Effect<
			{ session: Session | null; user: User | null },
			SupabaseAuthError
		>;
	}
>() {}

export const SupabaseLive = Layer.effect(
	SupabaseService,
	Effect.gen(function* () {
		const cookies = yield* CookiesService;
		const client: SupabaseClient<Database> = createServerClient(
			PUBLIC_SUPABASE_URL,
			PUBLIC_SUPABASE_ANON_KEY,
			{
				cookies: Effect.runSync(cookies.plainCookieSync())
			}
		);

		return {
			getClientSync: () => Effect.succeed(client),
			safeGetSessionAsync: () => {
				const sessionResult = Effect.promise(() => client.auth.getSession()).pipe(
					Effect.flatMap(({ data: { session }, error }) => {
						return error === null ? Effect.succeed(session) : Effect.fail(mapAuthError(error));
					})
				);

				const userResult = Effect.promise(() => client.auth.getUser()).pipe(
					Effect.flatMap(({ data: { user }, error }) => {
						return error === null ? Effect.succeed(user) : Effect.fail(mapAuthError(error));
					})
				);

				return Effect.all([sessionResult, userResult]).pipe(
					Effect.map(([session, user]) => ({ session, user }))
				);
			}
		};
	})
);
```

위 예시에서, `getClientSync`는 동기적으로 `SupabaseClient`를 반환하는 함수를 제공하고,
`safeGetSessionAsync`는 비동기적으로 세션과 사용자 정보를 가져오는 함수를 제공한다.

물론 결국 모든 `Effect`는 lazy하게 평가되긴 하지만, `Effect.runSync`를 사용할지 `Effect.runPromise`를 사용할지를
개발자가 잘 구분할 수 있도록 위 네이밍 컨벤션을 따라야 한다.
