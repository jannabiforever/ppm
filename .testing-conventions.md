# Testing Conventions for Effect.ts Services

## Overview

This document establishes testing conventions for our Effect.ts-based service architecture. These conventions ensure consistent, reliable, and maintainable tests across all service modules.

## Table of Contents

1. [Testing Philosophy](#testing-philosophy)
2. [Project Structure](#project-structure)
3. [Testing Tools & Setup](#testing-tools--setup)
4. [Effect.ts Testing Patterns](#effectts-testing-patterns)
5. [Service Testing Conventions](#service-testing-conventions)
6. [Mocking Strategies](#mocking-strategies)
7. [Test Categories](#test-categories)
8. [Async & Concurrency Testing](#async--concurrency-testing)
9. [Layer Management & Conflicts](#layer-management--conflicts)
10. [Database Testing Rules](#database-testing-rules)
11. [Error Validation Standards](#error-validation-standards)
12. [Fixture Management](#fixture-management)
13. [Naming Conventions](#naming-conventions)
14. [Best Practices](#best-practices)
15. [Examples](#examples)

## Testing Philosophy

### Core Principles
- **Test business logic, not implementation details**
- **Focus on Effect pipelines and error handling**
- **Isolate external dependencies (Supabase, APIs)**
- **Test both happy paths and error scenarios**
- **Maintain test reliability and determinism**
- **Avoid testing framework behavior** - Don't test Effect.ts Schema validation itself

### Effect.ts Specific Goals
- Verify Effect composition and chaining
- Test error propagation through Effect chains
- Validate service dependencies and injection
- Ensure proper resource cleanup and error handling
- Test time-dependent operations with deterministic timing
- Validate concurrent operations and race conditions
- Ensure proper Layer composition and isolation

### Modular Testing Principles
- **Service-Owned Test Infrastructure**: Each service module owns its mocks, fixtures, and test utilities
- **Minimize Global Dependencies**: Only truly cross-cutting concerns (base users, Supabase client) belong in global setup
- **Co-located Testing Assets**: Test mocks and fixtures live alongside the code they test
- **Independent Module Testing**: Adding a new service shouldn't require touching global test configuration
- **Composable Test Layers**: Service-specific mocks compose cleanly with shared infrastructure mocks
- **Isolated Test Failures**: Changes to one service's tests don't break other services' tests

## Project Structure

### Test File Organization
```
src/lib/modules/[module_name]/
├── __tests__/
│   ├── service.integration.test.ts  # Service integration tests
│   ├── service.unit.test.ts         # Business logic unit tests
│   ├── schema.test.ts               # Schema validation tests (minimal)
│   ├── mocks/
│   │   ├── [service_name]-service.mock.ts  # Service-specific mocks
│   │   └── [module_name]-fixtures.ts       # Module test data
│   └── fixtures/
│       ├── business-scenarios.ts     # Complex test scenarios
│       └── error-scenarios.ts        # Error condition testing
├── schema.ts
├── service.server.ts
└── index.ts
```

### Global Test Setup (Minimal)
```
src/lib/
├── __tests__/                      # Only truly global test infrastructure
│   ├── setup/
│   │   ├── global-environment.ts   # Effect runtime, env vars, timers
│   │   └── config.test.ts          # Verify test setup works
│   └── fixtures/
│       └── global/
│           ├── users.ts            # Base test users only
│           └── common-errors.ts    # Cross-cutting error patterns
├── shared/
│   └── __tests__/
│       ├── mocks/
│       │   └── supabase.mock.ts    # Shared Supabase mock utilities
│       └── test-helpers.ts         # Generic Effect.ts test helpers
└── modules/
    ├── task/
    │   └── __tests__/
    │       ├── mocks/
    │       │   ├── task-service.mock.ts
    │       │   └── task-fixtures.ts
    │       └── service.integration.test.ts
    ├── focus_session/
    │   └── __tests__/
    │       ├── mocks/
    │       │   ├── focus-session-service.mock.ts
    │       │   └── session-fixtures.ts
    │       └── service.integration.test.ts
    └── project/
        └── __tests__/
            ├── mocks/
            │   ├── project-service.mock.ts
            │   └── project-fixtures.ts
            └── service.integration.test.ts
```

## Testing Tools & Setup

### Required Dependencies
```json
{
  "devDependencies": {
    "@effect/vitest": "latest",
    "vitest": "latest",
    "@vitest/ui": "latest",
    "effect": "latest",
    "@effect/platform": "latest",
    "@effect/platform-node": "latest"
  }
}
```

### Vitest Configuration
```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    setupFiles: ['./src/__tests__/setup/test-environment.ts'],
    testTimeout: 10000, // 10s for integration tests
    hookTimeout: 5000,  // 5s for setup/teardown
    coverage: {
      provider: 'v8',
      include: ['src/lib/modules/**/*.ts'],
      exclude: ['**/__tests__/**', '**/*.test.ts', '**/types.ts'],
      thresholds: {
        statements: 80,
        branches: 75,
        functions: 80,
        lines: 80
      }
    },
    pool: 'threads',
    poolOptions: {
      threads: {
        singleThread: true // Prevent DB conflicts in tests
      }
    }
  }
});
```

## Effect.ts Testing Patterns

### 1. Basic Effect Testing
```typescript
import { Effect } from 'effect';
import { expect, test } from 'vitest';

test('should handle Effect success', async () => {
  const result = await Effect.succeed(42).pipe(
    Effect.runPromise
  );
  expect(result).toBe(42);
});

test('should handle Effect failure', async () => {
  await expect(
    Effect.fail(new Error('Test error')).pipe(
      Effect.runPromise
    )
  ).rejects.toThrow('Test error');
});
```

### 2. Testing Effect Generators
```typescript
test('should test Effect.gen pipeline', async () => {
  const result = await Effect.gen(function* () {
    const a = yield* Effect.succeed(10);
    const b = yield* Effect.succeed(20);
    return a + b;
  }).pipe(
    Effect.runPromise
  );
  expect(result).toBe(30);
});
```

### 3. Testing Service Dependencies
```typescript
import { Layer, Context } from 'effect';

// Create test layer
const TestServiceLive = Layer.succeed(
  TestService,
  TestService.of({
    someMethodAsync: () => Effect.succeed('test-result')
  })
);

test('should test service with dependencies', async () => {
  const result = await Effect.gen(function* () {
    const service = yield* TestService;
    return yield* service.someMethodAsync();
  }).pipe(
    Effect.provide(TestServiceLive),
    Effect.runPromise
  );
  
  expect(result).toBe('test-result');
});
```

## Service Testing Conventions

### 1. Service Method Testing Pattern
```typescript
// ✅ GOOD: Test the complete Effect pipeline
test('createTaskAsync should create task and return result', async () => {
  const mockSupabase = createMockSupabaseService({
    insertResult: mockTask
  });

  const result = await taskService.createTaskAsync(validInput).pipe(
    Effect.provide(mockSupabase),
    Effect.runPromise
  );

  expect(result).toEqual(mockTask);
});

// ❌ BAD: Testing implementation details
test('createTaskAsync should call supabase.getClientSync', () => {
  // Don't test internal method calls
});
```

### 2. Error Handling Testing
```typescript
test('should handle database errors gracefully', async () => {
  const mockSupabase = createMockSupabaseService({
    shouldFail: true,
    error: new SupabasePostgrestError('Connection failed')
  });

  await expect(
    taskService.createTaskAsync(validInput).pipe(
      Effect.provide(mockSupabase),
      Effect.runPromise
    )
  ).rejects.toThrow('Connection failed');
});

test('should handle business rule violations', async () => {
  const effect = focusSessionService.startFocusSessionAsync(input);

  // Provide mock that simulates active session exists
  const mockLayer = Layer.succeed(FocusSessionService, {
    getActiveFocusSessionAsync: () => Effect.succeed(mockActiveSession)
  });

  await expect(
    effect.pipe(
      Effect.provide(mockLayer),
      Effect.runPromise
    )
  ).rejects.toThrow('Active focus session already exists');
});
```

## Mocking Strategies

### 1. Shared Infrastructure Mocking (Minimal Global)
```typescript
// src/lib/shared/__tests__/mocks/supabase.mock.ts
export const createMockSupabaseService = (config: MockSupabaseConfig = {}) => {
  return Layer.succeed(SupabaseService, {
    getClientSync: () => Effect.succeed(createMockSupabaseClient(config) as never),
    safeGetSessionAsync: () => Effect.succeed({ session: null, user: null })
  });
};

export const mockConfigs = {
  successfulInsert: (data: unknown) => ({ insertResult: data, shouldFail: false }),
  databaseError: (message = 'Database error') => ({ shouldFail: true, error: new Error(message) }),
  // ... other common patterns
};
```

### 2. Module-Specific Service Mocking
```typescript
// src/lib/modules/task/__tests__/mocks/task-service.mock.ts
export const createMockTaskService = (overrides: Partial<TaskServiceMethods> = {}) => {
  const defaultMethods = {
    createTaskAsync: (input: CreateTaskInput) => Effect.succeed(createMockTask(input)),
    updateTaskStatusAsync: (id: string, status: TaskStatus) => 
      Effect.succeed(createMockTask({ id, status })),
    validateTaskStatusTransitionSync: (from: TaskStatus, to: TaskStatus) =>
      isValidTransition(from, to) ? Effect.void : Effect.fail(createTransitionError(from, to)),
    // ... all required methods with sensible defaults
  };
  
  return Layer.succeed(TaskService, { ...defaultMethods, ...overrides });
};

// src/lib/modules/focus_session/__tests__/mocks/focus-session-service.mock.ts
export const createMockFocusSessionService = (overrides = {}) => {
  const defaultMethods = {
    startFocusSessionAsync: () => Effect.succeed(mockFocusSession),
    endFocusSessionAsync: () => Effect.succeed({ ...mockFocusSession, closed_at: new Date().toISOString() }),
    getActiveFocusSessionAsync: () => Effect.succeed(null), // No active session by default
    // ... all required methods
  };
  
  return Layer.succeed(FocusSessionService, { ...defaultMethods, ...overrides });
};
```

### 3. Service Dependency Composition
```typescript
// src/lib/modules/focus_session/__tests__/service.integration.test.ts
const createTestLayers = (config: TestLayerConfig = {}) => {
  const mockSupabaseLayer = createMockSupabaseService(config.supabase);
  const mockTaskLayer = createMockTaskService(config.taskService);
  
  return FocusSessionLive.pipe(
    Layer.provide(Layer.mergeAll(mockSupabaseLayer, mockTaskLayer))
  );
};
```

## Test Categories

**Priority Order (High to Low Value):**
1. **Service Integration Tests** - End-to-end business workflows
2. **Business Logic Unit Tests** - Domain rules and calculations  
3. **Error Handling Tests** - Failure scenarios and recovery
4. **Schema Validation Tests** - Only when business-critical (use sparingly)

### 1. Service Integration Tests (High Priority)
```typescript
// service.test.ts
describe('FocusSessionService Integration', () => {
  test('should complete full session workflow', async () => {
    const mockLayers = Layer.mergeAll(
      createMockSupabaseService({ insertResult: mockSession }),
      createMockTaskService()
    );

    // Start session
    const session = await focusSessionService.startFocusSessionAsync({
      task_ids: ['task1', 'task2']
    }).pipe(Effect.provide(mockLayers), Effect.runPromise);

    expect(session.closed_at).toBeNull();

    // End session  
    const closedSession = await focusSessionService.endFocusSessionAsync(session.id, {
      task_completion_updates: [
        { task_id: 'task1', completed: true, seconds_spent: 1200 }
      ]
    }).pipe(Effect.provide(mockLayers), Effect.runPromise);

    expect(closedSession.closed_at).toBeDefined();
  });
});
```

### 2. Business Logic Unit Tests (Medium Priority)
```typescript
// service.unit.test.ts
describe('TaskService Business Logic', () => {
  test('validateTaskStatusTransitionSync should allow valid transitions', async () => {
    const result = await taskService.validateTaskStatusTransitionSync('planned', 'in_session').pipe(
      Effect.runPromise
    );
    expect(result).toBeUndefined(); // void success
  });

  test('calculateSessionDurationSync should compute correct duration', async () => {
    const session = createMockSession({
      started_at: '2024-01-01T10:00:00Z',
      closed_at: '2024-01-01T10:45:00Z'
    });
    
    const duration = await focusSessionService.calculateSessionDurationSync(session).pipe(
      Effect.runPromise
    );
    expect(duration).toBe(45); // minutes
  });
});
```

### 3. Error Handling Tests (Medium Priority)
```typescript
// service.error.test.ts  
describe('FocusSessionService Error Handling', () => {
  test('should handle database connection failures', async () => {
    const errorLayer = createMockSupabaseService({
      shouldFail: true,
      error: new SupabasePostgrestError({ message: 'Connection failed' })
    });

    await expect(
      focusSessionService.startFocusSessionAsync({
        task_ids: ['task1']
      }).pipe(
        Effect.provide(errorLayer),
        Effect.runPromise
      )
    ).rejects.toMatchObject({
      _tag: 'SupabasePostgrestError',
      message: 'Connection failed'
    });
  });

  test('should prevent multiple active sessions', async () => {
    const mockLayer = createMockSupabaseService({
      selectResult: mockActiveSession // Simulate existing active session
    });

    await expect(
      focusSessionService.startFocusSessionAsync({}).pipe(
        Effect.provide(mockLayer),
        Effect.runPromise
      )
    ).rejects.toMatchObject({
      _tag: 'ActiveFocusSessionExistsError'
    });
  });
});
```

## Async & Concurrency Testing

### 1. Time-Dependent Testing
```typescript
import { TestClock } from '@effect/platform';
import { Effect, Clock } from 'effect';

test('should handle scheduled operations', async () => {
  const testClock = TestClock.make();
  
  const result = await Effect.gen(function* () {
    const timedEffect = Effect.gen(function* () {
      yield* Effect.sleep('5 minutes');
      return 'completed';
    });

    const fiber = yield* Effect.fork(timedEffect);
    
    // Advance test clock
    yield* TestClock.adjust('5 minutes');
    
    return yield* Fiber.join(fiber);
  }).pipe(
    Effect.provide(testClock),
    Effect.runPromise
  );
  
  expect(result).toBe('completed');
});
```

### 2. Concurrent Operations Testing
```typescript
test('should handle concurrent session operations', async () => {
  const concurrentOperations = [
    focusSessionService.startFocusSessionAsync(input1),
    focusSessionService.startFocusSessionAsync(input2), // Should fail
    focusSessionService.startFocusSessionAsync(input3)  // Should fail
  ];

  const results = await Promise.allSettled(
    concurrentOperations.map(op => op.pipe(Effect.runPromise))
  );

  expect(results[0].status).toBe('fulfilled');
  expect(results[1].status).toBe('rejected');
  expect(results[2].status).toBe('rejected');
});
```

### 3. Race Condition Testing
```typescript
test('should prevent race conditions in task status updates', async () => {
  const taskId = 'test-task-id';
  
  // Only one should succeed, others should fail or be ignored
  const results = await Effect.all([
    taskService.updateTaskStatusAsync(taskId, 'in_session'),
    taskService.updateTaskStatusAsync(taskId, 'completed'),
    taskService.updateTaskStatusAsync(taskId, 'blocked')
  ], { concurrency: 'unbounded' }).pipe(
    Effect.runPromise
  );
  
  // Verify final state is consistent
  const finalTask = await taskService.getTaskByIdAsync(taskId).pipe(
    Effect.runPromise
  );
  expect(['in_session', 'completed', 'blocked']).toContain(finalTask.status);
});
```

## Layer Management & Conflicts

### 1. Layer Composition Rules
```typescript
// ✅ GOOD: Explicit layer merging with conflict resolution
const testLayers = Layer.mergeAll(
  mockSupabaseLayer,     // Highest priority
  mockTaskServiceLayer,
  mockAuthLayer          // Lowest priority
);

// ✅ GOOD: Override specific service methods
const customTaskLayer = Layer.succeed(TaskService, {
  ...defaultTaskServiceMethods,
  updateTaskStatusAsync: () => Effect.succeed(customMockTask)
});

// ❌ BAD: Conflicting layers without explicit resolution
const conflictingLayers = Layer.merge(
  Layer.succeed(TaskService, mockTaskService1),
  Layer.succeed(TaskService, mockTaskService2) // Which one wins?
);
```

### 2. Service Dependency Testing
```typescript
test('should resolve service dependencies correctly', async () => {
  // Test that FocusSessionService properly receives TaskService
  const mockTaskLayer = createMockTaskService({
    updateTaskStatusAsync: vi.fn(() => Effect.succeed(mockTask))
  });

  const testLayers = Layer.mergeAll(
    mockSupabaseLayer,
    mockTaskLayer,
    FocusSessionLive // Depends on both Supabase and TaskService
  );

  const result = await Effect.gen(function* () {
    const focusSession = yield* FocusSessionService;
    return yield* focusSession.startFocusSessionAsync(validInput);
  }).pipe(
    Effect.provide(testLayers),
    Effect.runPromise
  );

  expect(result).toBeDefined();
  expect(mockTaskLayer.updateTaskStatusAsync).toHaveBeenCalledWith(
    validInput.task_ids[0],
    'in_session'
  );
});
```

### 3. Layer Isolation Guidelines
```typescript
describe('Layer isolation tests', () => {
  let baseTestLayers: Layer.Layer<SupabaseService | TaskService>;

  beforeEach(() => {
    // Reset base layers for each test
    baseTestLayers = Layer.mergeAll(
      createMockSupabaseService(),
      createMockTaskService()
    );
  });

  test('should not affect other tests', async () => {
    // Each test gets fresh layer instances
    const customLayer = Layer.mergeAll(
      baseTestLayers,
      Layer.succeed(TaskService, {
        ...defaultTaskMethods,
        getTaskByIdAsync: () => Effect.succeed(specialMockTask)
      })
    );

    // Test-specific behavior doesn't leak
  });
});
```

## Database Testing Rules

### 1. Database Initialization
```typescript
// src/__tests__/setup/test-environment.ts
import { beforeEach, afterEach } from 'vitest';

beforeEach(async () => {
  // Clean database state
  await cleanupTestDatabase();

  // Seed minimal required data
  await seedTestDatabase();
});

afterEach(async () => {
  // Ensure clean state for next test
  await cleanupTestDatabase();
});

const cleanupTestDatabase = async () => {
  // Order matters: clean dependent tables first
  await testSupabase.from('session_tasks').delete().neq('id', '');
  await testSupabase.from('focus_sessions').delete().neq('id', '');
  await testSupabase.from('tasks').delete().neq('id', '');
  await testSupabase.from('projects').delete().neq('id', '');
};

const seedTestDatabase = async () => {
  // Insert minimal test data needed by all tests
  await testSupabase.from('users').insert(baseTestUser);
};
```

### 2. Transaction Testing
```typescript
test('should rollback on transaction failure', async () => {
  const invalidInput = { /* data that will cause constraint violation */ };

  // Count records before
  const beforeCount = await countRecords('focus_sessions');

  await expect(
    Effect.runPromise(focusSessionService.createFocusSessionAsync(invalidInput))
  ).rejects.toThrow();

  // Verify no partial data was committed
  const afterCount = await countRecords('focus_sessions');
  expect(afterCount).toBe(beforeCount);

  // Verify related tables are also unchanged
  const sessionTasksCount = await countRecords('session_tasks');
  expect(sessionTasksCount).toBe(0);
});
```

### 3. Database State Verification
```typescript
test('should maintain data consistency', async () => {
  const sessionId = await createTestSession();
  const taskIds = ['task1', 'task2'];

  // Perform operations
  await Effect.runPromise(
    focusSessionService.endFocusSessionAsync(sessionId, {
      task_completion_updates: [
        { task_id: 'task1', completed: true, seconds_spent: 1200 }
      ]
    })
  );

  // Verify database state
  const session = await getSessionFromDB(sessionId);
  expect(session.closed_at).toBeDefined();

  const sessionTasks = await getSessionTasksFromDB(sessionId);
  expect(sessionTasks).toHaveLength(2);
  expect(sessionTasks[0].seconds_spent).toBe(1200);

  const task1 = await getTaskFromDB('task1');
  expect(task1.status).toBe('completed');
});
```

## Error Validation Standards

### 1. Error Type Validation
```typescript
// ✅ GOOD: Specific error validation
test('should throw SupabasePostgrestError on database failure', async () => {
  test('should handle database errors gracefully', async () => {
    const mockSupabase = createMockSupabaseService({
      shouldFail: true,
      error: new SupabasePostgrestError('Connection timeout')
    });

    await expect(
      taskService.createTaskAsync(validInput).pipe(
        Effect.provide(mockSupabase),
        Effect.runPromise
      )
    ).rejects.toMatchObject({
      _tag: 'SupabasePostgrestError',
      message: 'Connection timeout'
    });
  });

// ✅ GOOD: Domain error validation
test('should throw DomainError for business rule violations', async () => {
  await expect(
    focusSessionService.startFocusSessionAsync(validInput).pipe(
      Effect.runPromise
    )
  ).rejects.toMatchObject({
    _tag: 'ActiveFocusSessionExistsError',
    message: expect.stringContaining('active session already exists')
  });
});
```

### 2. Error Propagation Testing
```typescript
test('should propagate errors through Effect chains', async () => {
  await expect(
    Effect.gen(function* () {
      const task = yield* taskService.createTaskAsync(invalidInput);
      const session = yield* focusSessionService.startFocusSessionAsync({
        task_ids: [task.id]
      });
      return session;
    }).pipe(
      Effect.runPromise
    )
  ).rejects.toThrow();
  
  // Verify no side effects occurred due to early failure
  const activeSessions = await focusSessionService.getActiveFocusSessionAsync().pipe(
    Effect.runPromise
  );
  expect(activeSessions).toBeNull();
});
```

### 3. Error Boundary Testing
```typescript
test('should handle partial failures gracefully', async () => {
  const multiTaskInput = {
    task_ids: ['valid-task', 'invalid-task', 'another-valid-task']
  };

  // Some operations may succeed, others fail
  const result = await focusSessionService.startFocusSessionAsync(multiTaskInput).pipe(
    Effect.catchAll(error => Effect.succeed({ error, partialSuccess: true })),
    Effect.runPromise
  );

  if ('error' in result) {
    // Verify which operations succeeded
    const validTasks = await taskService.getTasksAsync({ 
      task_ids: ['valid-task', 'another-valid-task'] 
    }).pipe(
      Effect.runPromise
    );
    expect(validTasks.some(t => t.status === 'in_session')).toBe(false);
  }
});
```

## Fixture Management

### 1. Module-Specific Fixtures
```typescript
// src/lib/modules/focus_session/__tests__/mocks/session-fixtures.ts
export const mockFocusSession: FocusSession = {
  id: 'fs_123',
  owner_id: 'user_123',
  project_id: 'proj_123',
  started_at: '2024-01-01T10:00:00Z',
  scheduled_end_at: '2024-01-01T10:50:00Z',
  closed_at: null,
  created_at: '2024-01-01T10:00:00Z',
  updated_at: '2024-01-01T10:00:00Z'
};

export const mockSessionTask: SessionTaskDB = {
  session_id: 'fs_123',
  task_id: 'task_123',
  order_index: 1,
  seconds_spent: 0,
  created_at: '2024-01-01T10:00:00Z',
  updated_at: '2024-01-01T10:00:00Z'
};

// Factory functions for test variations
export const createMockSession = (overrides: Partial<FocusSession> = {}) => ({
  ...mockFocusSession,
  ...overrides
});
```

### 2. Global Shared Fixtures (Minimal)
```typescript
// src/lib/__tests__/fixtures/global/users.ts
export const baseTestUser = {
  id: 'test_user_001',
  email: 'test@example.com',
  created_at: '2024-01-01T00:00:00Z'
};

export const createTestUser = (suffix: string) => ({
  ...baseTestUser,
  id: `test_user_${suffix}`,
  email: `test_${suffix}@example.com`
});
```

### 3. Module-Specific Business Scenarios
```typescript
// src/lib/modules/focus_session/__tests__/fixtures/business-scenarios.ts
export const focusSessionScenarios = {
  multiTaskSession: {
    startInput: {
      task_ids: ['task_1', 'task_2'],
      scheduled_duration_minutes: 50,
      project_id: 'proj_123'
    },
    endInput: {
      task_completion_updates: [
        { task_id: 'task_1', completed: true, seconds_spent: 1800 },
        { task_id: 'task_2', completed: false, seconds_spent: 900 }
      ]
    },
    expectedTaskStates: {
      'task_1': 'completed',
      'task_2': 'planned'
    }
  },

  emergencyCloseSession: {
    startInput: { task_ids: ['task_1'], scheduled_duration_minutes: 50 },
    endInput: { task_completion_updates: [{ task_id: 'task_1', completed: false, seconds_spent: 2700 }] },
    expectedSessionDuration: 45,
    expectedTaskStates: { 'task_1': 'planned' }
  }
};

export const errorScenarios = {
  activeSessionExists: {
    existingSession: mockFocusSession,
    newSessionInput: { task_ids: ['task_1'], scheduled_duration_minutes: 30 },
    expectedError: 'ActiveFocusSessionExistsError'
  }
};
```

### 4. Service-Specific Mock Services
```typescript
// src/lib/modules/focus_session/__tests__/mocks/focus-session-service.mock.ts
export const createMockFocusSessionService = (overrides = {}) => {
  return Layer.succeed(FocusSessionService, {
    startFocusSessionAsync: () => Effect.succeed(mockFocusSession),
    endFocusSessionAsync: () => Effect.succeed({ ...mockFocusSession, closed_at: '2024-01-01T10:45:00Z' }),
    getActiveFocusSessionAsync: () => Effect.succeed(null),
    ...overrides
  });
};

// src/lib/modules/task/__tests__/mocks/task-service.mock.ts
export const createMockTaskService = (overrides = {}) => {
  return Layer.succeed(TaskService, {
    updateTaskStatusAsync: (id, status) => Effect.succeed({ ...mockTask, id, status }),
    validateTaskStatusTransitionSync: (from, to) => 
      validTransitions[from]?.includes(to) ? Effect.void : Effect.fail(transitionError),
    ...overrides
  });
};
```

## Naming Conventions

### Test File Names
- `[service-name].test.ts` - Integration tests
- `[service-name].unit.test.ts` - Business logic unit tests
- `schema.test.ts` - Schema validation tests
- `[feature-name].integration.test.ts` - Cross-service integration tests

### Test Description Format
```typescript
// Pattern: "should [expected behavior] when [condition]"
test('should create focus session when valid input provided', () => {});
test('should throw error when active session already exists', () => {});
test('should update task status when session ends', () => {});

// Describe blocks: "[ServiceName] [method/feature]"
describe('FocusSessionService startFocusSessionAsync', () => {});
describe('TaskService status transitions', () => {});
```

## Best Practices

### 1. Test Isolation
- **Always provide fresh mock layers** for each test
- **Don't share mutable state** between tests
- **Use `beforeEach`** for test setup, not global state

### 2. Effect Testing Guidelines
- **Use `Effect.runPromise`** for async test execution
- **Test error scenarios** using `rejects.toThrow`
- **Provide all required services** via Layer composition
- **Test Effect composition**, not individual steps

### 3. Mock Strategy
- **Mock external dependencies** (Supabase, APIs)
- **Don't mock business logic** within the service under test
- **Use realistic mock data** that matches production schemas
- **Test both success and failure paths**
- **Keep service mocks co-located** with the service being tested
- **Reuse shared infrastructure mocks** (Supabase, auth) from `lib/shared/__tests__/mocks/`
- **Compose mock layers** rather than creating monolithic global mocks

### 4. Test Data Management
```typescript
// ✅ GOOD: Module-specific fixtures
// src/lib/modules/task/__tests__/mocks/task-fixtures.ts
export const createMockTask = (overrides = {}) => ({
  id: generateTestId('task'),
  title: 'Test Task',
  status: 'backlog',
  ...overrides
});

// ✅ GOOD: Isolated test data per test
test('should handle task creation', () => {
  const testTask = createMockTask({ title: 'Specific Task' });
  // Use testTask in this test only
});

// ❌ BAD: Shared mutable test data
const globalTestTask = { id: 'shared-task' };
test('should update task', () => {
  globalTestTask.title = 'Updated'; // Affects other tests
});

// ✅ GOOD: Compose layers for dependencies
const testLayers = FocusSessionLive.pipe(
  Layer.provide(Layer.mergeAll(
    createMockSupabaseService(config),
    createMockTaskService(taskOverrides)
  ))
);
```

### 5. Coverage Guidelines
- **Aim for 80%+ coverage** on service methods
- **100% coverage** on business logic functions
- **Focus on edge cases** and error scenarios
- **Don't test schema types** (they're compile-time checked)
- **Avoid testing framework behavior** - Focus on your business logic, not Effect.ts internals
- **Module-level coverage** - Each service module maintains its own coverage independently
- **Cross-service integration** - Test service boundaries, not internal implementation

### 6. External Dependencies
- **Mock ALL external I/O**: Database, HTTP, file system, timers
- **Use dependency injection**: All external services via Effect Context
- **No real network calls**: Mock APIs, webhooks, third-party services
- **Isolated file operations**: Mock file system interactions
- **Shared infrastructure mocks**: Common utilities in `lib/shared/__tests__/mocks/`
- **Service-specific mocks**: Module-owned dependencies in each service's `__tests__/mocks/`

### 7. Time and Concurrency
- **Use TestClock**: For all time-dependent operations
- **Avoid real timers**: No `setTimeout`, `setInterval` in tests
- **Test race conditions**: Concurrent operations, state conflicts
- **Deterministic timing**: Predictable test execution order

### 8. Modular Testing Guidelines
- **One service, one test directory**: Keep all test assets for a service in its `__tests__/` folder
- **Minimize cross-service dependencies**: Mock other services rather than importing their real implementations
- **Independent test execution**: Each service's tests should run independently without setup from other modules
- **Composable test infrastructure**: Build test layers by composing focused, single-responsibility mock services
- **Local test utilities**: Service-specific test helpers belong in the service's test directory
- **Global only when truly shared**: Only put test utilities in global setup if used by 3+ different service modules

## Examples

### Complete Service Test Example
```typescript
// src/lib/modules/task/__tests__/service.test.ts
import { Effect, Layer } from 'effect';
import { describe, test, expect, beforeEach } from 'vitest';
import { TaskService, TaskLive } from '../service.server';
import { createMockSupabaseService } from '../../__tests__/fixtures/mock-services';
import { mockTask, validCreateTaskInput } from './fixtures/mock-data';

describe('TaskService', () => {
  let mockSupabase: Layer.Layer<SupabaseService>;

  beforeEach(() => {
    mockSupabase = createMockSupabaseService({
      insertResult: mockTask,
      selectResult: mockTask
    });
  });

  describe('createTaskAsync', () => {
    test('should create task successfully', async () => {
      const result = await Effect.gen(function* () {
        const taskService = yield* TaskService;
        return yield* taskService.createTaskAsync(validCreateTaskInput);
      }).pipe(
        Effect.provide(Layer.mergeAll(TaskLive, mockSupabase)),
        Effect.runPromise
      );

      expect(result).toEqual(mockTask);
    });

    test('should handle database errors', async () => {
      const errorSupabase = createMockSupabaseService({
        shouldFail: true,
        error: new SupabasePostgrestError('Database connection failed')
      });

      await expect(
        Effect.gen(function* () {
          const taskService = yield* TaskService;
          return yield* taskService.createTaskAsync(validCreateTaskInput);
        }).pipe(
          Effect.provide(Layer.mergeAll(TaskLive, errorSupabase)),
          Effect.runPromise
        )
      ).rejects.toMatchObject({
        _tag: 'SupabasePostgrestError',
        message: 'Database connection failed'
      });
    });
  });
});
```

### Schema Test Example (Use Sparingly)
```typescript
// Only test schemas for business-critical validation rules
// Most schema validation should be tested through service integration tests

// src/lib/modules/task/__tests__/schema.test.ts
import { Schema } from 'effect';
import { describe, test, expect } from 'vitest';
import { CreateTaskSchema, TaskStatusSchema } from '../schema';

describe('Task Schemas - Business Critical Only', () => {
  // Only test if this validation prevents actual business problems
  describe('TaskStatusSchema', () => {
    test('should enforce valid task status transitions', () => {
      const validStatuses = ['backlog', 'planned', 'in_session', 'blocked', 'completed'];
      
      validStatuses.forEach(status => {
        const result = Schema.decodeUnknownSync(TaskStatusSchema)(status);
        expect(result).toBe(status);
      });
    });

    test('should reject invalid status that could break business logic', () => {
      expect(() => 
        Schema.decodeUnknownSync(TaskStatusSchema)('invalid_status')
      ).toThrow();
    });
  });
});

// PREFER: Test validation through service integration tests instead
describe('TaskService Integration - Input Validation', () => {
  test('should handle invalid input gracefully in business workflow', async () => {
    const invalidTask = { title: '', status: 'invalid' };
    
    await expect(
      taskService.createTaskAsync(invalidTask).pipe(
        Effect.provide(mockLayers),
        Effect.runPromise
      )
    ).rejects.toThrow();
  });
});
```

## Command Line Usage

### Running Tests
```bash
# Run all tests
npm run test

# Run specific module tests
npm run test src/lib/modules/task

# Run with coverage
npm run test:coverage

# Run in watch mode
npm run test:watch

# Run integration tests only
npm run test -- --grep="integration"

# Run with database cleanup
npm run test:db

# Run performance/timing tests
npm run test:timing

# Run concurrency tests
npm run test:concurrent
```

### Package.json Scripts
```json
{
  "scripts": {
    "test": "vitest",
    "test:watch": "vitest --watch",
    "test:coverage": "vitest --coverage",
    "test:ui": "vitest --ui",
    "test:db": "TEST_DB_CLEANUP=true vitest",
    "test:timing": "vitest --grep='timing|timeout|duration'",
    "test:concurrent": "vitest --grep='concurrent|race|parallel'"
  }
}
```

---

## Migration Strategy: Centralized → Modular

### Phase 1: Create Module-Specific Test Directories
```bash
# For each existing service module
mkdir -p src/lib/modules/task/__tests__/{mocks,fixtures}
mkdir -p src/lib/modules/focus_session/__tests__/{mocks,fixtures}
mkdir -p src/lib/modules/project/__tests__/{mocks,fixtures}

# Create shared test infrastructure
mkdir -p src/lib/__tests__/{setup,fixtures/global}
mkdir -p src/lib/shared/__tests__/mocks
```

### Phase 2: Move Service-Specific Assets
```bash
# Move service mocks to their respective modules
mv src/__tests__/setup/mock-services.ts → src/lib/modules/task/__tests__/mocks/task-service.mock.ts
# Extract TaskService mock only, leave others for their respective modules

# Move test fixtures
mv src/__tests__/fixtures/focus-session-data.ts → src/lib/modules/focus_session/__tests__/mocks/session-fixtures.ts

# Move business scenario data
cp src/lib/modules/focus_session/__tests__/fixtures/business-scenarios.ts → 
   src/lib/modules/focus_session/__tests__/fixtures/business-scenarios.ts
```

### Phase 3: Refactor Global Infrastructure
```typescript
// Keep only in src/lib/__tests__/setup/global-environment.ts
- Effect runtime setup
- Environment variables
- Global fake timers
- Basic test utilities

// Keep only in src/lib/shared/__tests__/mocks/supabase.mock.ts
- createMockSupabaseService
- mockConfigs
- Basic Supabase client mocking

// Keep only in src/lib/__tests__/fixtures/global/
- baseTestUser, createTestUser
- Common cross-cutting error patterns
```

### Phase 4: Update Test Imports
```typescript
// Before (centralized)
import { createMockTaskService } from '../../../../__tests__/setup/mock-services';
import { mockFocusSession } from '../../../../__tests__/fixtures/focus-session-data';

// After (modular)
import { createMockTaskService } from '../mocks/task-service.mock';
import { createMockSupabaseService } from '../../../shared/__tests__/mocks/supabase.mock';
import { mockFocusSession } from '../mocks/session-fixtures';
```

### Phase 5: Validate Independence
```bash
# Test each service module independently
npm run test src/lib/modules/task/__tests__/
npm run test src/lib/modules/focus_session/__tests__/
npm run test src/lib/modules/project/__tests__/

# Verify no cross-dependencies
# Each should run without requiring setup from other modules
```

### Migration Checklist
- [ ] Create new directory structure
- [ ] Move service-specific mocks and fixtures
- [ ] Extract and minimize global test setup
- [ ] Update import paths in test files
- [ ] Verify independent test execution
- [ ] Remove old centralized test files
- [ ] Update CI/CD test runners for new structure

## Summary

These conventions ensure:
- **High-value testing** focused on business logic over framework behavior
- **Proper isolation** of external dependencies
- **Comprehensive coverage** of business scenarios and error cases
- **Maintainable test code** that follows Effect.ts best practices
- **Fast, reliable test execution** with proper mocking strategies
- **Pragmatic approach** that avoids testing trivial schema validation

**Testing Priority:**
1. **Service Integration Tests** - Real business workflows and user scenarios
2. **Business Logic Unit Tests** - Domain rules, calculations, and pure functions
3. **Error Handling Tests** - Failure recovery and edge cases
4. **Schema Tests** - Only for business-critical validation (use sparingly)

Follow these conventions to build a robust test suite that provides confidence in your Effect.ts service architecture while avoiding maintenance overhead from low-value tests.
